<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Das Unwahrscheinliche</title>
    <atom:link href="http://localhost:8080/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>http://localhost:8080</link>
    <description>von Julian Steinwachs</description>
    <pubDate>Sun, 22 Apr 2018 02:00:00 +0200</pubDate>
    <generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator>
    <language>en</language>
    <item>
      <title>Kryptoökonomie - Signaturen bei Bitcoin</title>
      <link>http://localhost:8080/articles/cryptoeconomics_video_002/</link>
      <pubDate>Sun, 22 Apr 2018 02:00:00 +0200</pubDate>
      <guid isPermaLink="true">http://localhost:8080/articles/cryptoeconomics_video_002/</guid>
      <author></author>
      <description>&lt;div style=&quot;position:relative;height:0;padding-bottom:56.25%&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/EZA7ffO3bkU?rel=0&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; style=&quot;position:absolute;width:100%;height:100%;left:0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Kryptoökonomie - Vorwort</title>
      <link>http://localhost:8080/articles/cryptoeconomics_video_001/</link>
      <pubDate>Sun, 15 Apr 2018 02:00:00 +0200</pubDate>
      <guid isPermaLink="true">http://localhost:8080/articles/cryptoeconomics_video_001/</guid>
      <author></author>
      <description>&lt;div style=&quot;position:relative;height:0;padding-bottom:56.25%&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/E9TK5DViuug?rel=0&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; style=&quot;position:absolute;width:100%;height:100%;left:0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Gewaltenteilung bei Bitcoin</title>
      <link>http://localhost:8080/articles/bitcoin_politics/</link>
      <pubDate>Sun, 17 Dec 2017 01:00:00 +0100</pubDate>
      <guid isPermaLink="true">http://localhost:8080/articles/bitcoin_politics/</guid>
      <author></author>
      <description>&lt;p&gt;Bei Bitcoin gibt es im Wesentlichen drei Gruppen von politischen Akteuren: Nutzer, Miner und Entwickler. Sie alle stehen in gegenseitiger Abhängigkeit. Die Nutzer vertrauen den Entwicklern, dass die Bitcoin-Software sicher ist und messen deshalb der Währung Bitcoin einen Wert zu. Die Entwickler vetrauen wiederum den Minern, dass diese dafür sorgen, die Sicherheit der Blockchain zu gewährleisten. Und die Miner vetrauen darauf, dass die Nutzer der Währung Bitcoin einen Wert beimessen, in der sie bezahlt werden. Der Wert der Währung folgt also aus einem Zirkelschluß, was Bitcoin schon immer einiges an Kritik eingebracht hat. Es ist erstaunlich wie dieses System es schafft, sich an seinen eigenen Schnürsenkeln in immer weitere Höhen zu ziehen.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Dadurch, dass sowohl Nutzer, als auch Entwickler und Miner an der Wertschöpfung beteiligt sind, tragen auch alle eine politische Rolle. Es herscht eine Gewaltenteilung vergleichbar mit der in einem Rechtsstaat. Die Entwickler entprechen etwa der Legislative und die Miner etwa der Exekutive. Manch einer würde vielleicht die Miner eher als Judikative sehen. Tatsächlich haben die Miner aber keinerlei Macht über die Auslegung der Regeln, weil jeder Knoten ebenfalls alle Transaktionen automatisiert überprüft. Die Judikative ist also vollständig durch die Software weg-automatisiert (“code is law”).&lt;/p&gt;
&lt;p&gt;Innerhalb der drei Gruppen gibt es wiederum unterschiedliche Parteien. Bei den Nutzern gibt es sowohl Privatanwender, die die Bitcoin-Software selber betreiben als auch Unternehmen, die Dienste innerhalb der Bitcoin-Plattform zur Verfügung stellen. Die Entwickler lassen sich der jeweiligen Software zuschreiben, für die sie entwickeln. Neben der meistgenutzten Software “bitcoin-core” gibt es mittlerweile auch noch weitere Software-Projekte, die im selben Bitcoin-Netzwerk operieren. Die Miner sind schließlich in unterschiedliche Miningpools aufgeteilt, die um die größte Hashrate konkurrieren.&lt;/p&gt;
&lt;p&gt;In diesem Jahr (2017) zeigt sich, glaube ich, dass diese Gewaltenteilung bei Bitcoin eine seiner größten Stärken ist. Die Entwickler sind nämlich schon seit Langem uneinig darüber wie Bitcoin zukünftig mit einem größeren Transaktionsaufkommen zurecht kommen soll. Ein den Minern nahestehender Teil will die Größe der Blöcke erhöhen, damit mehr Transaktionen in einen Block passen. Die Entwickler des meistgenutzten Clients “bitcoin-core” (Core-Entwickler) wollen aber stattdessen Technologien ermöglichen, die es erlauben Transaktionen in Zahlungskanälen zu bündeln. &lt;/p&gt;
&lt;p&gt;Ich will jetzt nicht auf die Unterschiede im Detail eingehen. Viel interessanter ist es sich anzuschauen, wie solche Meinungsverschiedenheiten aufgelöst werden. Nach einem langen Stillstand in der Debatte entschied sich die den Minern nahestehende Fraktion der Entwickler ihre Software inkompatibel zu der der anderen zu machen, um die größeren Blockgrößen zu erlauben. Ein solches Vorgehen wird Hard-Fork genannt. Die Inkompatibilität wurde so einprogrammiert, dass sie erst ab dem 1. August diesen Jahres griff. Ab dem 1. August lag die Blockchain dann in zwei Versionen mit identischen Kontoständen vor, wovon die eine inkompatibel mit dem einen Teil der Software und der andere inkompatibel mit dem anderen Teil der Software waren. Je nachdem welche Software der jeweilige Nutzer einsetzte, operierte er danach auf der einen oder der anderen Version. Die Nutzer hatten jetzt also die Wahl die eine, die andere oder beide Versionen weiterzubenutzen.&lt;/p&gt;
&lt;p&gt;Die zweite Version mit den veränderten Regeln bekam den namen Bitcoin Cash und wurde an Exchanges gehandelt. Erst dadurch, dass ein Teil der Nutzer Bitcoin Cash einen Wert beigemessen hatte, war es möglich, dass ein Teil der Miner ihre Arbeit auf dessen Blockchain fortführten und sich damit von Bitcoin abwandten. Wäre das nicht passiert, hätten die Miner ihre Belohnung nicht in ihre Lokalwährung umtauschen und damit ihre Stromrechnung bezahlen können.&lt;/p&gt;
&lt;p&gt;Im Grunde treten die Client-Software-Projekte der Entwickler auf wie politische Parteien, für die die Nutzer abstimmen können. Den Projekten kommt dann die Aufgabe, den Mehrheitswillen der Nutzer möglichst getreu in Software abzubilden. Ansonsten laufen sie Gefahr zu viele Nutzer an Konkurrenz-Projekte zu verlieren. Sobald die Nutzer dem jeweiligen Coin einen zu geringen Wert beimessen, können die Miner ihre Ausgaben nicht mehr begleichen und machen Verlust.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Warum funktionale Programmierung?</title>
      <link>http://localhost:8080/articles/why_functional/</link>
      <pubDate>Sun, 17 Dec 2017 01:00:00 +0100</pubDate>
      <guid isPermaLink="true">http://localhost:8080/articles/why_functional/</guid>
      <author></author>
      <description>&lt;p&gt;Funktionale Programmierung erlebt derzeit in mehreren Breichen eine Aufleben. Sie erlaubt es einfacher deklarativ zu programmieren. So lässt sich die fachliche Steuerungslogik besser von der darunter liegenden algorithmischen Arbeitslogik trennen.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;funktional-vs-imperativ&quot;&gt;Funktional vs. Imperativ&lt;/h3&gt;
&lt;p&gt;Bei der imperativen Programmierung wird Code als Abfolge von Befehlen begriffen, die strikt nacheinandern abgearbeitet werden. Dadurch ist die volle Kontrolle über den Ablauf der Befehle gewährleistet. Gerade für Performance-kritische und Hardware-nahe Programmierung ist der Kontrollfluß und insbesondere die volle Kontrolle über den Arbeitsspeicher essenziell. Als Beispiel zur Demonstration der Konzepte dient im folgenden die Zubereitung eines Rühreis.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mixture = whisk(eggs)
mixture = season(mixture, salt, pepper)
fry(mixture)
&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mixture
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bei der funktionalen Programmierung hingegen wird der Code als Verschachtelung von Ausdrücken betrachtet, die ausgewertet werden sollen. &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fry(
  season(
    whisk(eggs),
    salt,  
    pepper
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hierbei geht die Kontrolle über die Abfolge der Befehle etwas verloren. Die als erste ausgewertete Funktion &lt;code&gt;whisk(eggs)&lt;/code&gt; steht z.B. unscheinbar in der Mitte des Ausdrucks. In vielen rein funktionalen Sprachen ist es vom Programmcode her oft nicht vorherzusehen zu welchem Zeitpunkt die Auswertung stattfindet, weil die Auswertung zum spätestmöglichen Zeitpunkt verschoben wird. Auf der anderen Seite lässt sich für jeden Teilausdruck eindeutig zurückverfolgen, wo die einzelnen Werte herkommen, beziehungsweise wie die Daten durch den Ausdruck hindurchfließen. Diese Art der Programmierung gewährleistet also volle Kontrolle über den Datenfluß.&lt;/p&gt;
&lt;p&gt;Mithilfe der Deklaration von Konstanten lässt sich die Kontrolle über die Abfolge der Aufrufe wieder herstellen. Dadruch wird der Code auch einfacher zu lesen.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; mixture = whisk(eggs)
&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; seasonedMix = season(
    mixture,
    salt,  
    pepper
  )
&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fry(seasonedMix)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Solange es Konstanten sind - also Variablen, die nur einmal zugewiesen werden - lässt sich der eigentliche Ausdrucksbaum durch Einsetzen der Werte in das Endergebnis rekonstruieren. Sobald aber eine wiederholte Zuweisung erfolgt oder eine Funktion aufgerufen wird, die den Wert eines Parameter verändert, so wie &lt;code&gt;fry(mixture)&lt;/code&gt; im ersten Codebeispiel, gilt diese einfache Ersetzbarkeit nicht mehr und der Code lässt sich nicht mehr als ein Ausdruck darstellen. Hieraus ergibt sich der Zusammenhang zwischen funktionaler Programmierung und unveränderlichem Zustand. Sobald veränderliche Zustandsvariablen benutzt werden, opfert man die Kontrolle über den Datenfluß.&lt;/p&gt;
&lt;h3 id=&quot;funktionen-h-herer-ordnung&quot;&gt;Funktionen höherer Ordnung&lt;/h3&gt;
&lt;p&gt;Um überhaupt ausschließlich mit Konstanten Programme schreiben zu können, die echte Probleme lösen, benötigt man sogenannte Funktionen höherer Ordnung. Diese sind Funktionen die entweder eine andere Funktion als Parameter annehmen oder eine Funktion als Ergebnis zurückgeben. Eine der am häufigsten benutzten Funktionen höherer Ordnung ist die Funktion &lt;code&gt;map&lt;/code&gt; in JavaScript. &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];
&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; mul = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;
arr.map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt; =&amp;gt;&lt;/span&gt; mul*x) &lt;span class=&quot;comment&quot;&gt;// [3,6,9]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In obigem Beispiel wird ein neues Array erzeugt, in dem jedes Element mit 3 multipliziert ist. Hier kommen zwei weitere Sprachfeatures zum Tragen, die die funktionale Programmierung vereinfachen. Zum einen die Funktion, die an &lt;code&gt;map&lt;/code&gt; als Parameter übergeben wird, anonym definiert mithilfe einer Pfeilfunktion (Lambda). Zum anderen hat diese Funktion Zugriff auf die Konstante &lt;code&gt;mul&lt;/code&gt;, obwohl sie außerhalb definiert wurde (genannt Closure). Diese drei Sprachfeatures (Funktionen höherer Ordnung, Lambdas und Closures) ermöglichen zusammen die vielen ausdrucksstarken Fluent-APIs, die zeitgemäße Libraries zur Verfügung stellen.&lt;/p&gt;
&lt;h3 id=&quot;funktional-vs-rein-funktional&quot;&gt;Funktional vs rein funktional&lt;/h3&gt;
&lt;p&gt;Weil Fluent-APIs so beliebt sind haben die meistgenutzen Sprachen mittlerweile alle die funktionalen Features nachgerüstet. Die meisten Programmiersprachen kann man also als funktional bezeichnen, weil sie in ihrer Mächtigkeit den &lt;em&gt;rein&lt;/em&gt; funktionalen Sprachen (wie Haskel, Clojure und F#) in nichts nachstehen. Rein funktionale Sprachen verankern aber zusätzlich das Prinzip von unveränderlichem Zustand in sich. Sie erlauben entweder gar keine wiederholte Zuweisung von Variablen oder nur in bestimmten transaktionsartigen Kontexten. Das heißt rein funktionale Sprachen haben eine absichtlich reduzierte Mächtigkeit, die die Komplexität der Programme begrenzen soll. Dadurch werden die Programme schwerer zu schreiben, aber dafür einfach zu verstehen und zu warten.&lt;/p&gt;
&lt;p&gt;Ein anderes Beispiel für eine solche freiwillige Beschränkung der Mächtigkeit sind statische Typ-Systeme. Hier wird dem Programm die Möglichkeit genommen, den Typ einer Variable zur Laufzeit zu verändern. Auch hierdurch soll Komplexität eingegrenzt werden.&lt;/p&gt;
&lt;h3 id=&quot;deklarative-programmierung&quot;&gt;Deklarative Programmierung&lt;/h3&gt;
&lt;p&gt;Beispiele für FLuent-APIs, die in letzter Zeit beliebt geworden sind, sind LinQ in .Net, Java-Streams, ReactiveX sowie viele Frameworks für Dependency-Injection. Ein Grund für ihre Beliebtheit ist das dahinterliegende Paradigma der deklarativen Programmierung, was soviel bedeutet wie die Trennung von Arbeits- und Steuerungscode. Dabei ergibt sich oft, dass sich Arbeitscode weit besser wiederverwenden lässt als Steuerungscode, der ja von der konkreten Geschäftslogik abhängt. Nehmen wir als Beispiel im folgenden die Array-Operation &lt;code&gt;filter&lt;/code&gt; in JavaScript.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Ohne Trennung&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; activeUsers = [];
&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; users.length; i++) {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(users[i].active){
    activeUsers.push(users[i])
  }
}

&lt;span class=&quot;comment&quot;&gt;// Deklarativ&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; activeUsers = users.filter(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt; =&amp;gt;&lt;/span&gt; x.active)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Man sieht sofort, dass die Version mit herausgetrenntem Arbeitscode viel kompakter und einfacher zu lesen ist. Es gebietet schon das DRY-Prinzip (don’t repeat yourself), dass &lt;code&gt;filter&lt;/code&gt; benutzt wird statt überall im Code dieselbe For-Schleife auszuprogrammieren. Bei rein funktionaler Programmierung ergibt sich also die Trennung von Arbeits- und Steuerungscode auf natürliche Weise. Dadurch, dass Arbeitscode (wie obiges filter-Beispiel) nur schwer rein funktional auszudrücken ist, ist man hierfür auf die Runtime/Infrastruktur/Frameworks angewiesen. So bleibt der eigene Code, der das konkrete Problem der Anwendung löst, lesbar und leicht zu verstehen, während die schwierigen wiederkehrenden Probleme outgesourced werden.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>CouchDB: alt aber oho</title>
      <link>http://localhost:8080/articles/couchdb/</link>
      <pubDate>Thu, 31  Aug 2017 02:00:00 +0200</pubDate>
      <guid isPermaLink="true">http://localhost:8080/articles/couchdb/</guid>
      <author></author>
      <description>&lt;p&gt;&lt;a href=&quot;http://couchdb.apache.org/&quot;&gt;CouchDB&lt;/a&gt; wird gerne als eine von viele NoSQL-Datenbanken verschrien, was dem Projekt in keiner Weise gerecht wird. CouchDB ist eine dokumentenorientierte Datenbank, die von Grund auf als vollwertiges Backend für Webanwendungen konzipiert ist. D.h. es ist keine klassische Geschäftslogik-Schicht vorgesehen bzw. notwendig. Stattdessen setzt CouchDB konsequent auf Command-Query-Repsonsibility-Segregation (CQRS) und bietet an, Validierungs-Funktionen (auf Command-Seite) und Aggregations-Funktionen (für die Query-Seite) zu hinterlegen. Diese werden in JavaScript definiert und bilden die Geschäftslogik vollständig ab. Die Applikationslogik (der Fluß/Ablauf der Anwendung) wird von der Browserseite gesteuert.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Die Ansätze: Dokumentenorientiert, CQRS, JavaScript im Backend und Applikationslogik im Browser sind Ansätze, die zur Zeit als CouchDB rauskam (2005) noch höchst experimentell waren, aber mittlerweile etabliert sind. Ich habe CouchDB schon seit einiger Zeit auf dem Schirm und endlich das richtige Projekt gefunden um sie mal auszuprobieren: Mein neues &lt;a href=&quot;https://github.com/tschaul/AJExpenditor2&quot;&gt;Haushaltsbuch&lt;/a&gt;. Mein altes Haushaltsbuch (namentlich AJExpenditor) ist mittlerweile etwas in die Jahre gekommen. Der Ansatz, alle Einträge in einer großen json-Datei zu speichern, skaliert nicht mehr mit.&lt;/p&gt;
&lt;p&gt;Bei vielen Datenbanken muss man, sobald das Datenmodel etwas komplexer ist, sich immer entscheiden, ob man sicherstellen will, dass alle Daten konsistent sind (also die Daten strikt normalisieren) und dafür lange Abfragezeiten in Kauf nimmt, oder ob man Inkonsistenzen riskiert (durch Denormalisierung) und dadurch aber effizienter auf die Daten zugreifen kann.&lt;/p&gt;
&lt;p&gt;Im Fall des AJExpenditor betrifft das die Aggregation der Ausgaben für bestimmte Zeiträume (Monatlich, Jährlich, Alle, …). Im alten System musste nach jeder Änderung eine Bereinigungsroutine alle Daten ab dem betroffenen Zeitpunkt neu berechnen, um wieder Konsistenz herzustellen.&lt;/p&gt;
&lt;p&gt;CouchDB trennt Lese- und Schreibzugriffe konsequent und löst so das Dilemma. Dieser Ansatz wird gängigerweise als CQRS bezeichnet. Es gibt ein strikt normalisiertes WriteModel, wovon sich die ReadModels, also die abfragebaren Daten, ableiten. Wichtig ist dabei, dass das WriteModel kein Wissen über die ReadModels hat. In CouchDB ist das über sogenannte Views gelöst. Eine View besteht aus einer map-Funktion die Dokumente einem, keinem oder mehreren Schlüsseln zuordnet. Zusätzlich kann eine weitere reduce-Funktion definiert werden, die die Dokumente mit gleichem Schlüssel aggregiert (also z.B. eine Summe über diese bildet). CouchDB speichert die Zwischenergebnisse seiner Berechnung sehr effizient in einem B-tree ab und kann dadurch die Ergebnisse der View bei jedem Schreibzugriff anpassen. Dieses Feature ist natürlich wie gemacht für die Summierung meiner Haushalts-Ausgaben aus bestimmten Perioden.&lt;/p&gt;
&lt;p&gt;Die Views werden in sogenannten Designdokumenten in der Datenbank hinterlegt. Außerdem lässt sich eine Validierungsfunktion definieren. Die Validierungsfunktion wird vor jedem Schreibzugriff ausgeführt und stellt die Konsistenz der Dokumente sicher. Sie kann jedoch nicht Konsistenz über mehrere Dokumente hinweg sicherstellen. Zum Beispiel kann CouchDB nicht sicherstellen, dass eine Referenz auf ein anderes Objekt via dessen ID nicht ins leere greift. Aggregate von Domänenobjekten müssen deshalb immer in einem Dokument gespeichert sein. Das beduetet, man muss bei der Datenmodellierung gut aufpassen, dass man die Aggregate/Dokumente richtig schneidet.&lt;/p&gt;
&lt;p&gt;Die Logik der map- und reduce-Funktionen ist dabei in JavaScript definiert. Die Wahl von JavaScript als Abfrage-Sprache ist für das Alter des CouchDB-Projekts wirklich beachtlich. Ein Problem, dass mir dabei immer wieder in die Quere kam, ist, dass die JavaScript-VM, die in CouchDB eingesetzt wird, etwas in die Jahre gekommen ist. Immer wieder haben bestimmte Aufrufe, z.B. auf Arrays, nicht funktioniert, weil die Funktionen nicht vorhanden waren. Generell ist das aber ein überwindbares Hindernis. Ich habe für die Designdokumente sowohl auf Module als auch auf TypeScript verzichtet. Beides ist sicher möglich zu verwenden aber ecklig einzurichten.&lt;/p&gt;
&lt;p&gt;Ein Bonus der Designdokumente ist, dass sie auch statische Dateien als Anhänge enthalten können. Diese können auch statisches html enthalten, welches dann über http abgerufen werden kann. Sprich, die Datenbank kann das Frontend zu seiner Anwendung ausliefern. Dadurch wird die ganze Anwendung sozusagen self-contained. Dieser Anwendungsfall ist ausdrücklich so gedacht. Die beiliegende Datenbankverwaltung funktioniert ebenfalls auf diese Weise.&lt;/p&gt;
&lt;p&gt;Jenseits von Views, Validierungsfunktion und ein paar anderen Funktionen lässt sich in der Datenbank jedoch keine Logik hinterlegen. Deshalb muss der gesamte Anwendungsfluß im Frontend gesteuert werden. Es bietet sich also an, eine Single-Page-Application einzusetzen. Die API, mit der das Frontend mit der Datenbank kommuniziert, ist vollständig Rest-basiert, d.h. auch hier fällt der Bedarf für eine Middleware (z.B. in nodejs) weg. In Fall des AJExpenditor2 habe ich mich für einen React+MobX-Stack entschieden mit React-Bootstrap als UI-Framework. &lt;/p&gt;
&lt;p&gt;Als Fazit muss ich sagen, dass ich wirklich erstaunt bin, wie gut sich CouchDB für die Entwicklung einer Web-Applikation nach allen aktuell gültigen Regeln der Kunst eignet. CouchDB war einfach zu früh dran und verdient heutzutage weit mehr Beachtung. Vor allem in der heutigen Mirco-Service-Welt wäre CouchDB für viele Anwendungsfälle die richtige Wahl.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Generator-Funktionen in JavaScript</title>
      <link>http://localhost:8080/articles/js_generators/</link>
      <pubDate>Thu, 15 Jun 2017 02:00:00 +0200</pubDate>
      <guid isPermaLink="true">http://localhost:8080/articles/js_generators/</guid>
      <author></author>
      <description>&lt;p&gt;Vielleicht hat der ein oder anderen schon einmal bemerkt, dass einige Supermarktkassen den Kassenbon bereits während des Scannvorgangs der Waren drucken. Das macht eine Menge Sinn und reduziert gerade bei größeren Einkäufen die Wartezeit beim Bezahlvorgang erheblich.&lt;/p&gt;
&lt;p&gt;Nun ist diese häppchenweise Verarbeitung der Eingaben sicher ein schickes Feature, aber es erhöht die technische Komplexität. Generator-Funktionen sind eine Abstraktion um diese Komplexitätserhöhung einzugrenzen, indem sie es erlauben Iterationen von außerhalb zu steuern.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In JavaScript kamen Generator-Funktionen mit dem ECMAScript-2015-Standard (ES6) dazu. Sie werden mit einem Asterisk-Symbol nach dem &lt;code&gt;function&lt;/code&gt;-Keyword gekennzeichnet. Ruft man eine solche Funktion auf erhält man nicht direkt einen Wert, sondern ein Generator-Objekt, welches die Erzeugung neuer Werte steuert. Durch den Aufruf von &lt;code&gt;next()&lt;/code&gt; erhält man ein Objekt mit dem nächsten Wert und der Information ob die Iteration abgeschlossen ist.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;oneToThree&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;
}

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; gen = oneToThree();

&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(gen.next()); &lt;span class=&quot;comment&quot;&gt;// { value: 1, done: false }&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(gen.next()); &lt;span class=&quot;comment&quot;&gt;// { value: 2, done: false }&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(gen.next()); &lt;span class=&quot;comment&quot;&gt;// { value: 3, done: false }&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(gen.next()); &lt;span class=&quot;comment&quot;&gt;// { value: undefined, done: true }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Das erhaltene Generator-Objekt kann auch als Iterator verwendet werden. Dadurch lässt sich über die Ergebnisse auch mittels &lt;code&gt;for ... of&lt;/code&gt; iterieren:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; oneToThree()){
    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(num)
}
&lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Für unser Eingangsbeispiel der Supermarktkasse sind wir jetzt aber nur einen kleinen Schritt weiter. Denn dort sollen in der gesteuerten Schleife keine Werte erzeugt werden wie oben, sondern die Werte sollen in der Schleife Eingabe für Eingabe verarbeitet werden. In diesem benutzt man das Generator-Objekt als Observer. Ein Generator ist schlicht die Vereinigung von Iterator und Observer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;logSomeStuff&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;){
        nextInput = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;;
        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(nextInput);
    }
}
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; gen = logSomeStuff();
gen.next()
gen.next(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// foo&lt;/span&gt;
gen.next(&lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// bar&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hier wird das Schlüsselwort &lt;code&gt;yield&lt;/code&gt; als Ausdruck benutzt und nicht als Statement. Die Auswertung des Ausdrucks hat den Effekt, dass die Funktion an dieser Stelle gestoppt wird bis der Observer mittels &lt;code&gt;next(...)&lt;/code&gt; mit einem neuen Wert gefüttert wird. Dann wird der neue Wert an Stelle des &lt;code&gt;yield&lt;/code&gt;-Ausdrucks gestellt und die Funktion läuft weiter. Damit der Generator überhaupt bis zum ersten &lt;code&gt;yield&lt;/code&gt; ausgeführt wird muss einmal &lt;code&gt;next()&lt;/code&gt; ohne Parameter aufgerufen werden, analog zum Iterator-Fall. Der erst Aufruf von &lt;code&gt;next(...)&lt;/code&gt; ist also immer ohne Parameter.&lt;/p&gt;
&lt;p&gt;Mit diesem letzten Beispiel haben wir bereits den eingangs erwähnten Anwendungsfall des Supermarktkassen-Druckers erschlagen. Generator-Funktionen haben aber noch weit mehr zu bieten. Insbesondere für die asynchrone Programmierung sind Generator-Funktionen ein mächtiges Werkzeug, wie wir weiter unten sehen werden.&lt;/p&gt;
&lt;p&gt;Man kann nämlich auch beide Aspekte des Generators (Observer und Iterator) kombinieren um bei jeder Iteration ein Teilergebnis zurückzugeben. Hier tritt aber die sprachliche Obskurität auf, dass &lt;code&gt;yield&lt;/code&gt; sowohl als Statement als auch als Ausdruck verwendet wird. Zuerst wird das &lt;code&gt;yield&lt;/code&gt;-Statement ausgeführt, also ein Wert für die Iteration generiert. Anschließend wird das &lt;code&gt;yield&lt;/code&gt;-Statement durch den Wert ersetzt und der Generator wird bis zum nächsten &lt;code&gt;yield&lt;/code&gt; ausgeführt. Folgendes Beispiel stellt einen Generator dar, der zurückgibt ob der gefütterte Werte größer ist als der letzte.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;goingUp&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; old = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; now = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;){
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; newval = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; now &amp;gt; old;
        old = now;
       now = newval;
    }
}

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; gen = goingUp();
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(gen.next().value)  &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(gen.next(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;).value)  &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(gen.next(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;).value)  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(gen.next(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).value)  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(gen.next(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).value)  &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(gen.next(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;).value)  &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Eine solcher Generator kann z.B. benutzt werden um das erste lokale Maximum einer Zahlenreihe zu finden, ohne dass der Konsument der Funktion alle Werte zur Verfügung stellen muss. Das kann nützlich sein, wenn z.B. die Werte einzeln oder Batch-weise aus einer Datenbank gelesen werden müssen.&lt;/p&gt;
&lt;p&gt;Die doppelte Natur von Generator-Funktionen lässt sich außerdem ausnutzen um asynchronen JavaScript-Code leichter lesbar zu gestalten. Dazu schreiben wir uns eine wiederverwendbare Funktion &lt;code&gt;runAsync&lt;/code&gt; die als einzigen Parameter eine Generator-Funktion erwartet, welche Promise-Objekte zurückgibt. Promises sind Stellvertreter-Objekte für zukünftige Rückgabewerte und entsprechen etwa Futures in Java/C++ oder Tasks in c#. Die &lt;code&gt;runAsync&lt;/code&gt;-Funktion nimmt die Promises entgegen und füttert asynchron nach deren Auflösung das Ergebnis zurück in den Generator. Zwecks der Kürze ist in folgendem Beispiel die Fehlerbehandlung absichtlich ausgelassen.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;runAsync&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;generator&lt;/span&gt;)&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; it = generator();
    (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;iterate&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val&lt;/span&gt;)&lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; ret = it.next( val );
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!ret.done) {
            ret.value.then( iterate );
        }
    })();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dadurch können wir nun eine asynchrone Funktion so schreiben als wäre sie synchron. Im Folgenden geben die Funktionen &lt;code&gt;getFoo&lt;/code&gt; und &lt;code&gt;getBar&lt;/code&gt; asynchron die Strings “foo” und “bar” zurück.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;printFooBar&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; part1 = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; getFoo()
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; part2 = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; getBar()
    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(part1+part2)
}

runAsync(printFooBar) &lt;span class=&quot;comment&quot;&gt;// foobar&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nach der Auflösung des von &lt;code&gt;getFoo&lt;/code&gt; erhaltenen Promise-Objekts wird das &lt;code&gt;yield&lt;/code&gt;-Statement “&lt;code&gt;yield getFoo()&lt;/code&gt;“ durch den String “foo” ersetzt und der Variable &lt;code&gt;part1&lt;/code&gt; zugewiesen. Erst danach wird mit &lt;code&gt;getBar&lt;/code&gt; das nächste Promise-Objekt angefordert.&lt;/p&gt;
&lt;p&gt;Im neueren ECMAScript-2016-Standard (ES7), welcher noch im Draft-Zustand ist, erhält dieser spezielle Anwendungsfall für Generator-Funktionen mit &lt;code&gt;async/await&lt;/code&gt; seine eigene Syntax. Dadurch braucht man keine eigene &lt;code&gt;runAsync&lt;/code&gt;-Funktion mehr.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printFooBar&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;{
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; part1 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; getFoo()
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; part2 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; getBar()
    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(part1+part2)
}

printFooBar() &lt;span class=&quot;comment&quot;&gt;// foobar&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unter der Haube läuft in beiden Fällen genau das selbe ab. Bis zur Finalisierung von ES7 lässt sich diese Funktionalität aber ebenfalls wie gezeigt erzielen. Für den produktiven Einsatz empfehle ich die Library “co” (&lt;a href=&quot;https://github.com/tj/co&quot;&gt;https://github.com/tj/co&lt;/a&gt;).&lt;/p&gt;
&lt;h4 id=&quot;referenzen-&quot;&gt;Referenzen:&lt;/h4&gt;
&lt;p&gt;&lt;br/&gt;
[Video] Evolution of JavaScript: from ES5 to ES6 to ES7 &lt;br/&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=_8Qyk5j_b-g&quot;&gt;https://www.youtube.com/watch?v=_8Qyk5j_b-g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The Basics Of ES6 Generators&lt;br/&gt;
&lt;a href=&quot;https://davidwalsh.name/es6-generators&quot;&gt;https://davidwalsh.name/es6-generators&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ES6 Generators in Depth &lt;br/&gt;
&lt;a href=&quot;http://2ality.com/2015/03/es6-generators.html&quot;&gt;http://2ality.com/2015/03/es6-generators.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>